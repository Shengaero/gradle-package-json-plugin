/*
 * Copyright 2018 Kaidan Gustave
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress("RemoveEmptyPrimaryConstructor", "PropertyName", "unused", "MemberVisibilityCanBePrivate")
package me.kgustave.gradle.pkg.json.plugin.conventions

import groovy.lang.Closure
import me.kgustave.gradle.pkg.json.data.Person
import me.kgustave.gradle.pkg.json.data.PkgJson
import me.kgustave.gradle.pkg.json.internal.Open
import org.gradle.api.Action
import org.gradle.api.tasks.Internal
import java.util.*

@Open class PkgJsonConvention constructor() {
    /////////////////////////
    // GENERAL INFORMATION //
    /////////////////////////

    /**
     * The `name` property for a package.json
     *
     * This is a required field, and must be set, or else the owning
     * [PkgJsonTask][me.kgustave.gradle.pkg.json.plugin.PkgJsonTask] will fail.
     *
     * ### Example
     *
     * In build.gradle:
     * ```groovy
     * name 'my-package'
     * ```
     *
     * Generated package.json:
     * ```json
     * "name": "my-package"
     * ```
     */
    lateinit var name: String

    /**
     * The `version` property for a package.json
     *
     * This is a required field, and must be set, or else the owning
     * [PkgJsonTask][me.kgustave.gradle.pkg.json.plugin.PkgJsonTask] will fail.
     *
     * ### Example
     *
     * In build.gradle:
     * ```groovy
     * version '1.0'
     * ```
     *
     * Generated package.json:
     * ```json
     * "version": "1.0"
     * ```
     */
    lateinit var version: String

    var private: Boolean = false

    var description: String? = null

    var main: String? = null

    var tags = emptyList<String>()
        set(value) { field = value.distinct() }

    //////////////////
    // AUTHOR FIELD //
    //////////////////

    @set:Internal
    @get:Internal
    internal var _author: Person? = null

    /**
     * The author convention used to configure the `author`
     * property for a package.json.
     *
     * @see PersonConvention
     */
    val author: PersonConvention = PersonConvention { _author = it }

    fun author(action: Action<in PersonConvention>) {
        author.invoke(action)
    }

    fun author(closure: Closure<Any>) {
        author.invoke(closure)
    }

    fun author(author: String) {
        author(object: Closure<Any>(null) {
            override fun call(): Any = author
        })
    }

    ///////////////////////
    // DEPENDENCY FIELDS //
    ///////////////////////

    /**
     * The `dependencies` property for a package.json
     *
     * The values of the map are serialized to the names of
     * dependencies, where their values are the corresponding
     * versions.
     *
     * For configuring development-only dependencies, use
     * the [devDependencies] property.
     *
     * ### Example
     *
     * In build.gradle:
     * ```groovy
     * dependencies (
     *   'chalk': '2.4.1'
     * )
     * ```
     *
     * Generated package.json:
     * ```json
     * "dependencies": {
     *   "chalk": "2.4.1"
     * }
     * ```
     */
    var dependencies = emptyMap<String, String>()

    /**
     * The `devDependencies` property for a package.json.
     *
     * This is configured in a similar manner to the
     * [dependencies] property.
     *
     * ### Example
     *
     * In build.gradle:
     * ```groovy
     * devDependencies (
     *   'mocha': '5.3.0'
     * )
     * ```
     *
     * The following will be produced in the package.json
     * generated by the plugin:
     *
     * ```json
     * "devDependencies": {
     *   "mocha": "5.3.0"
     * }
     * ```
     */
    var devDependencies = emptyMap<String, String>()

    var peerDependencies = emptyMap<String, String>()

    //////////////
    // LICENSES //
    //////////////

    private var _licenses = LinkedList<String>()

    /**
     * The `license` property for a package.json.
     *
     * This delegates to [license] and multiple calls to set
     * this will not overwrite the previous values provided.
     *
     * ### Example
     *
     * In build.gradle:
     * ```groovy
     * license 'Apache-2.0'
     * license 'ISC'
     *
     * assert licenses.size() == 2
     * ```
     *
     * Generation in the package.json is documented
     * in the [licenses] property documentation.
     */
    var license: String?
        get() = _licenses.getOrNull(0)
        set(value) = _licenses.addFirst(value)

    /**
     * The `licenses` property for a package.json.
     *
     * This is a _distinct_ list of license names.
     *
     * **Note**: generation of the property in an output
     * package.json file varies based on the number
     * of license names provided!
     *
     * ### Single License
     *
     * In build.gradle:
     * ```groovy
     * license 'Apache-2.0'
     * ```
     * _or_
     * ```groovy
     * licenses ['Apache-2.0']
     * ```
     *
     * Generated package.json:
     * ```json
     * "license": "Apache-2.0"
     * ```
     *
     * ### Multiple Licenses
     *
     * In build.gradle:
     * ```groovy
     * licenses ['Apache-2.0', 'ISC']
     * ```
     *
     * Generated package.json:
     * ```json
     * "licenses": ['Apache-2.0', 'ISC']
     * ```
     */
    var licenses: List<String>
        get() = _licenses
        set(value) { _licenses = value.asSequence().distinct().toCollection(LinkedList()) }

    @Internal internal fun toPkgJson(): PkgJson {
        require(::name.isInitialized) { "package name is required" }
        require(::version.isInitialized) { "package version is required" }

        return PkgJson(
            name = name,
            version = version,
            private = private,
            description = description,
            main = main,
            author = _author,
            tags = tags,
            licenses = licenses,
            license = licenses.getOrNull(0),
            dependencies = dependencies,
            devDependencies = devDependencies,
            peerDependencies = peerDependencies
        )
    }

    /**
     * Configuration for a package.json field that takes a "person" as an argument.
     *
     * In json form, this is an object with three keys:
     *
     * 1) [name][PersonConvention.name] - The name of the person.
     * 2) [email][PersonConvention.email] - The person's email.
     * 3) [url][PersonConvention.url] - The person's url (presumably to a website).
     *
     * Only the name must be specified, all other fields are optional, but note that if the name is
     * not specified mutations to instances of this class have no effect.
     *
     * This convention delegates back to the owning [package-json-convention][PkgJsonConvention].
     */
    inner class PersonConvention
    internal constructor(private val delegate: (person: Person) -> Unit) {
        private lateinit var _name: String

        /**
         * The name of the person.
         */
        var name: String
            get() = _name
            set(value) {
                _name = value
                buildPerson()
            }

        /**
         * The person's email.
         */
        var email: String? = null
            set(value) {
                field = value
                if(nameIsInit) {
                    buildPerson()
                }
            }

        /**
         * The person's url (presumably to a website).
         */
        var url: String? = null
            set(value) {
                field = value
                if(nameIsInit) {
                    buildPerson()
                }
            }

        @get:Internal internal val nameIsInit get() = ::_name.isInitialized

        @Internal internal operator fun invoke(action: Action<in PersonConvention>) {
            action.execute(this)
            buildPerson()
        }

        @Internal internal operator fun invoke(closure: Closure<Any>) {
            closure.delegate = this
            when(val output = closure.call()) {
                null, is Unit -> buildPerson()
                is CharSequence -> delegate(Person.string("$output"))
                else -> throw IllegalArgumentException("Output type of closure is not valid: ${output::class.java}")
            }
        }

        private fun buildPerson() {
            require(nameIsInit) { "Name must be initialized when configuring!" }
            delegate(Person(name, email, url))
        }
    }

    internal companion object {
        @Internal internal const val NAME = "pkg"
    }
}
